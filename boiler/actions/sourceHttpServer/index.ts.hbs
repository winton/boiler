import http, { IncomingMessage, ServerResponse } from "http"
import { performance } from "perf_hooks"
import pino from "pino"

import { OkRoute } from "./routes/ok"

interface Route {
  match: (req: http.IncomingMessage) => boolean
  route: (
    req: http.IncomingMessage
  ) => Promise<[number, string]>
}

// âœ‹ Add new routes here!
const routes: Route[] = [new OkRoute(this.log)]

export class {{class}} {
  okRoute: OkRoute
  log = pino()
  routes: Route[]
  server: http.Server
  shutdown = false

  constructor() {
    this.server = http.createServer(
      this.httpListener.bind(this)
    )

    const handler = this.shutdownHandler.bind(this)

    process.once("uncaughtException", handler)
    process.once("unhandledRejection", handler)
    process.once("SIGINT", handler)
    process.once("SIGTERM", handler)
  }

  async httpListener(
    req: IncomingMessage,
    res: ServerResponse
  ): Promise<void> {
    const now = performance.now()
    let body: string, status: number

    if (this.shutdown) {
      status = 503
    } else {
      for (const route of routes) {
        if (route.match(req)) {
          ;[status, body] = await route
            .route(req)
            .catch(e => {
              this.log.error(e)
              return [500]
            })
          break
        }
      }
    }

    res.statusCode = status || 404

    res.statusMessage =
      body || http.STATUS_CODES[res.statusCode]

    this.log.info(
      req.url,
      res.statusCode,
      (performance.now() - now).toFixed(3) + "ms"
    )

    res.end()
  }

  shutdownHandler(signalOrError: string | Error): void {
    this.shutdown = true

    if (typeof signalOrError === "string") {
      this.log.info(`Received signal: ${signalOrError}`)
    } else if (signalOrError) {
      this.log.error(signalOrError)
    }

    this.server.close(err => {
      if (err) {
        this.log.error(err)
        process.exit(1)
      }

      process.exit()
    })
  }
}
